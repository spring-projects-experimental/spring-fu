Spring Fu is an **incubating** https://kotlinlang.org/[**Kotlin**] microframework that makes it easy to create lightweight https://spring.io/projects/spring-framework[Spring]-powered applications leveraging **https://spring.io/blog/2017/08/01/spring-framework-5-kotlin-apis-the-functional-way[functional configuration]**.

It is a thin but opinionated layer on top of a subset of Spring Framework 5.1, Spring Data, Spring Security and other Spring projects that provides what you need to develop easily applications, like https://github.com/spring-projects/spring-boot[Spring Boot], but with very different programming model:

* Functional bean registration instead of JavaConfig
* Features are configured explicitly
* Expressive configuration via Kotlin https://kotlinlang.org/docs/reference/type-safe-builders.html[domain-specific languages] (DSL)
* Flexible programmatic configuration
* Minimal reflection usage
* No classpath scanning to find annotated classes
* No annotation processing
* Modules provide integration with JVM ecosystem and configuration DSL
* Reactive web client and server based on WebFlux functional API
* https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md[Coroutines] support for imperative async programming
* JAR minimization via removal of unneeded Spring packages
* Self-sufficient opinionated documentation (Kotlin, constructor injection, functional configuration, WebFlux, Coroutines, etc.)

== Current status

Spring Fu first milestone https://github.com/sdeleuze/spring-fu/milestone/1[`1.0.0.M1`] is currently under active development. It is based on Spring Framework 5.1. For now you can clone the repository, explore the source code, try to play with the sample application, and send us your feedback on the `#spring` channel of http://slack.kotlinlang.org/[Kotlin Slack]. Feel free to https://github.com/sdeleuze/spring-fu/blob/master/CONTRIBUTING.adoc[contribute] fixes or new modules via pull requests.

Notice that some features currently incubating in Spring Fu **may** be later integrated in other Spring projects.

== Functional configuration

Spring Fu functional configuration is leveraging Kotlin DSL that allows you to configure your application explicitly. Each custom block like `configuration`, `actuators` or `webflux` is in fact a more high level `beans {}` block with a custom DSL provided for easy configuration. Since this configuration is code, you can use any kind of custom programmatic bean registration without having to implement your own `@Conditional` annotation.

```kotlin
val app = application {
	configuration {
	    AppConfiguration(name = env["SYSTEM_ENV"] ?: "default")
	}
	actuators(beans = false, mapping = false)
    logging {
        level(INFO)
        level("org.springframework", DEBUG)
        logback {
            consoleAppender()
            rollingFileAppender(file = File("log.txt"))
        }
    }
	profile("data") {
		bean<UserRepository>()
		bean<ArticleRepository>()
		mongodb(uri = "mongodb://myserver.com/foo")
	}
	profile("web") {
		bean<HtmlHandler>()
		bean<ApiHandler>()
		webflux {
			server(netty()) {
				cors(origin = "example.com")
				mustache()
				codecs {
					jackson()
					protobuf()
				}
				routes(routes)
				security {
					// ...
				}
			}
			client {
				codecs {
					jackson()
				}
			}
		}
	}
	// Functional configuration supports any kind of custom programmatic bean registration
	if (env.activeProfiles.any { it.startsWith("foo") }) {
		bean<Foo>()
	}
}

data class AppConfiguration(
	val name: String,
	val remoteUrl: String  = "http://localhost:8080"
)

val routes = routes {
	val htmlHandler = ref<HtmlHandler>()
	val apiHandler = ref<ApiHandler>()
	GET("/", htmlHandler::blog)
	GET("/article/{id}", htmlHandler:article)
	"/api".nest {
		GET("/", apiHandler::list)
		POST("/", apiHandler::create)
		PUT("/{id}", apiHandler::update)
		DELETE("/{id}", apiHandler::delete)
	}
}

fun main(args: Array<String) {
	app.run(await = true, profiles = "data, web")
}
```

=== JavaConfig versus functional bean definition

Functional bean definition allows to define beans in an efficient way with minimal reflection usage, no proxy and with a concise Kotlin DSL that takes advantage of https://kotlinlang.org/docs/reference/inline-functions.html#reified-type-parameters[reified type parameters] to avoid type erasure. The `beans {}` block is in fact a regular https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/ApplicationContextInitializer.html[`ApplicationContextInitializer`].

|=====
a|**JavaConfig** |**Functional bean definition**
a|
```kotlin
 @Configuration
 class MyConfiguration {

  @Bean
  fun foo() = Foo()

  @Bean
  fun bar(foo: Foo) = Bar(foo)
}
```

a|
```kotlin
val myConfiguration = beans {
  bean<Foo>()
  // Implicit autowiring by constructor
  bean<Bar>()
}
|=====

=== `@Component` scanning versus functional bean definition

Functional bean definition is explicit, does not imply any classpath scanning and supports constructor parameters autowiring.

|=====
a|**`@Component` scanning** |**Functional bean definition**
a|
```kotlin
@Component
class Foo {
  // ...
}

@Component
class Bar(private val f: Foo) {
  // ...
}
```

a|
```kotlin
class Foo {
  // ...
}
class Bar(private val f: Foo) {
  // ...
}

beans {
  bean<Foo>()
  bean<Bar>()
}
|=====

=== Annotation-based controller versus Kotlin WebFlux router

Kotlin WebFlux router provides a simple but powerful way to implement your web application. HTTP API, streaming but also viw rendering are supported.

|=====
a|**Annotation-based controller** |**Kotlin WebFlux router**
a|
```kotlin
@RestController
@RequestMapping("/api/article")
class MyController(private val r: MyRepository) {

  @GetMapping("/")
  fun findAll() =
    r.findAll()

  @GetMapping("/{id}")
  fun findOne(@PathVariable id: Long) =
    repository.findById(id)
  }
}
```

a|
```kotlin
router {
  val r = ref<MyRepository>()
  "/api/article".nest {
    GET("/") {
      r.findAll()
    }
    GET("/{id}") {
      val id = it.pathVariable("id")
      r.findById(id)
    }
  }
}
|=====

== Reference documentation

https://github.com/sdeleuze/spring-fu/tree/master/core[Core]

Modules: https://github.com/sdeleuze/spring-fu/tree/master/modules/dynamic-configuration[Dynamic configuration],
https://github.com/sdeleuze/spring-fu/tree/master/modules/jackson[Jackson], https://github.com/sdeleuze/spring-fu/tree/master/modules/mongodb[MongoDB] with  https://github.com/sdeleuze/spring-fu/tree/master/modules/mongodb/coroutines[Coroutines] support, https://github.com/sdeleuze/spring-fu/tree/master/modules/mustache[Mustache], https://github.com/sdeleuze/spring-fu/tree/master/modules/test[Test], https://github.com/sdeleuze/spring-fu/tree/master/modules/webflux[WebFlux]
with https://github.com/sdeleuze/spring-fu/tree/master/modules/webflux/coroutines[Coroutines], https://github.com/sdeleuze/spring-fu/tree/master/modules/webflux/netty[Netty] and https://github.com/sdeleuze/spring-fu/tree/master/modules/webflux/tomcat[Tomcat] support,

Planned modules: CORS, security, logging, multipart, Embedded MongoDB server, Reactive SQL

== Samples

* https://github.com/sdeleuze/spring-fu/tree/master/samples/simple-webapp[Simple webapp]

== Credits

In addition to the whole Spring and Reactor teams, kudos to https://github.com/tgirard12[Thomas Girard] for its https://github.com/tgirard12/spring-webflux-kotlin-dsl[spring-webflux-kotlin-dsl] experiment that initially demonstrated this approach was possible and to https://github.com/konrad-kaminski[Konrad Kaminski] for his awesome https://github.com/konrad-kaminski/spring-kotlin-coroutine[spring-kotlin-coroutine] project.