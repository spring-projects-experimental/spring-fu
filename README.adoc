Spring Fu is an incubating https://kotlinlang.org/[**Kotlin**] micro-framework that makes it easy to create lightweight https://spring.io/projects/spring-framework[Spring]-powered applications leveraging https://spring.io/blog/2017/08/01/spring-framework-5-kotlin-apis-the-functional-way[functional configuration].

== Overview

Spring Fu a thin but opinionated layer on top of a subset of Spring Framework, Spring Data, Spring Security and other Spring projects that provides what you need to develop easily applications, like https://github.com/spring-projects/spring-boot[Spring Boot], but with very different programming model:

* Functional bean registration instead of JavaConfig
* Features are configured explicitly
* Expressive configuration via Kotlin https://kotlinlang.org/docs/reference/type-safe-builders.html[domain-specific languages] (DSL)
* Flexible programmatic configuration
* Minimal reflection usage
* No classpath scanning to find annotated classes
* No annotation processing
* Modules provide integration with JVM ecosystem and configuration DSL
* Reactive web client and server based on https://docs.spring.io/spring/docs/current/spring-framework-reference/html/web-reactive.html#web-reactive[WebFlux] functional API
* https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md[Coroutines] support for imperative async programming
* JAR minimization via removal of unneeded Spring packages
* Self-sufficient opinionated documentation (Kotlin, constructor injection, functional configuration, WebFlux, Coroutines, etc.)

Notice that some features currently incubating in Spring Fu, like Coroutines support, **may** be later integrated in other Spring projects.

In addition to the whole Spring and Reactor teams, credits to https://github.com/tgirard12[Thomas Girard] for its https://github.com/tgirard12/spring-webflux-kotlin-dsl[spring-webflux-kotlin-dsl] experiment that initially demonstrated this approach was possible and to https://github.com/konrad-kaminski[Konrad Kaminski] for his awesome https://github.com/konrad-kaminski/spring-kotlin-coroutine[spring-kotlin-coroutine] project.

== Getting started

To start with Spring Fu, you can read the https://repo.spring.io/libs-snapshot-local/org/springframework/fu/spring-fu-docs/1.0.0.BUILD-SNAPSHOT/reference.html[**reference documentation**].

You can also have a look to the sample applications:

* https://github.com/sdeleuze/spring-fu/tree/master/samples/reactive-webapp[Reactive webapp]
* https://github.com/sdeleuze/spring-fu/tree/master/samples/coroutines-webapp[Coroutines webapp]

Spring Fu https://github.com/sdeleuze/spring-fu/milestone/1[`1.0.0.M1`] is currently under active development so no release is available yet, but you can clone the repository, import it into Intellij IDEA, try to play with the tests and sample applications.

Please send us your feedback on the `#spring` channel of http://slack.kotlinlang.org/[Kotlin Slack]. Feel free to open issues, https://github.com/sdeleuze/spring-fu/blob/master/CONTRIBUTING.adoc[contribute] fixes or new modules via pull requests.

== Functional configuration

Spring Fu functional configuration is leveraging Kotlin DSL that allows you to configure your application explicitly. Each custom block like `configuration`, `actuators` or `webflux` is in fact a more high level `beans {}` block with a custom DSL provided for easy configuration. Since this configuration is code, you can use any kind of custom programmatic bean registration without having to implement your own `@Conditional` annotation.

```kotlin
val app = application {
	configuration {
	    AppConfiguration(name = env["SYSTEM_ENV"] ?: "default")
	}
	actuators(beans = false, mapping = false)
	logging {
		level(INFO)
		level("org.springframework", DEBUG)
		logback {
			consoleAppender()
			rollingFileAppender(file = File("log.txt"))
		}
	}
	profile("data") {
		bean<UserRepository>()
		bean<ArticleRepository>()
		mongodb(uri = "mongodb://myserver.com/foo")
	}
	profile("web") {
		bean<HtmlHandler>()
		bean<ApiHandler>()
		webflux {
			server(netty()) {
				cors(origin = "example.com")
				mustache()
				codecs {
					jackson()
					protobuf()
				}
				routes(routes)
				security {
					// ...
				}
			}
			client {
				codecs {
					jackson()
				}
			}
		}
	}
	// Any kind of custom conditional bean definition is possible
	if (env.activeProfiles.any { it.startsWith("foo") }) {
		bean<Foo>()
	}
}

data class AppConfiguration(
	val name: String,
	val remoteUrl: String  = "http://localhost:8080"
)

val routes = routes {
	val htmlHandler = ref<HtmlHandler>()
	val apiHandler = ref<ApiHandler>()
	GET("/", htmlHandler::blog)
	GET("/article/{id}", htmlHandler:article)
	"/api".nest {
		GET("/", apiHandler::list)
		POST("/", apiHandler::create)
		PUT("/{id}", apiHandler::update)
		DELETE("/{id}", apiHandler::delete)
	}
}

fun main(args: Array<String) {
	app.run(await = true, profiles = "data, web")
}
```

=== Comparison with JavaConfig

Functional bean definition allows to define beans in an efficient way with minimal reflection usage, no proxy and with a concise Kotlin DSL that takes advantage of https://kotlinlang.org/docs/reference/inline-functions.html#reified-type-parameters[reified type parameters] to avoid type erasure. The `beans {}` block is in fact a regular https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/ApplicationContextInitializer.html[`ApplicationContextInitializer`].

|=====
a|**JavaConfig** |**Functional bean definition**
a|
```kotlin
 @Configuration
 class MyConfiguration {

  @Bean
  fun foo() = Foo()

  @Bean
  fun bar(foo: Foo) = Bar(foo)
}
```
a|
```kotlin
val myConfiguration = beans {
  bean<Foo>()
  // Implicit autowiring by constructor
  bean<Bar>()
}
|=====

=== Comparison with `@Component`

Functional bean definition is explicit, does not imply any classpath scanning and supports constructor parameters autowiring.

|=====
a|**`@Component` scanning** |**Functional bean definition**
a|
```kotlin
@Component
class Foo {
  // ...
}

@Component
class Bar(private val f: Foo) {
  // ...
}
```
a|
```kotlin
class Foo {
  // ...
}
class Bar(private val f: Foo) {
  // ...
}

beans {
  bean<Foo>()
  bean<Bar>()
}
|=====

=== Comparison with controllers

Kotlin WebFlux router provides a simple but powerful way to implement your web application. HTTP API, streaming but also viw rendering are supported.

|=====
a|**Annotation-based controller** |**Kotlin WebFlux router**
a|
```kotlin
@RestController
@RequestMapping("/api/article")
class MyController(private val r: MyRepository) {

  @GetMapping("/")
  fun findAll() =
    r.findAll()

  @GetMapping("/{id}")
  fun findOne(@PathVariable id: Long) =
    repository.findById(id)
  }
}
```
a|
```kotlin
router {
  val r = ref<MyRepository>()
  "/api/article".nest {
    GET("/") {
      r.findAll()
    }
    GET("/{id}") {
      val id = it.pathVariable("id")
      r.findById(id)
    }
  }
}
|=====
